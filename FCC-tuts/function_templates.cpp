#include <iostream>
#include <cstring>

using namespace std;


//a function template

template <typename T> 
T maximum(T a, T b);

//this is not an actual c++ code, but a blueprint which the complier will use to generate code and hence this helps with code repetion while overloading functions

//once an instance of a function is generated by the compiler using the template, if we call the function again with same instance the compiler will not generate the code again instead will use the last instance

//function specialization
//we can bypass the template code by specialization for a special type of arguments

template <>
const char* maximum<const char*> (const char* a, const char* b){

    cout << "Specialization called" << endl;
    return (strcmp(a,b) > 0) ? a : b;

}
    
int main()
{
    cout << "Int version: " << maximum(10, 20) << endl;
    cout << "Double version: " << maximum(100.44, 99.34) << endl;
    cout << "Double version: " << maximum("Rishi", "Bishi") << endl;

    //if we pass a pointer to template, it will compare adresses, and then if we dereference that adress, we may not get the maximum value, as the function is comparing the functions.

    //template type deduction and explicit arguments
    int a = 34;
    int b = 8;
    double c {45.67};
    double d {10.45};
    std::string e {"Rishi"};
    std::string f {"Bishi"};

    const char* g {"Rishi"}; //const char pointers
    const char* i {"Bishi"}; // if passed throught the template, instead of lexographic comparison, they will be compared by the adress. hence we will specialize the template for these

    cout << "Int version called: " << maximum(a, b) << endl;
    cout << "Double version called: " << maximum(c, d) << endl;
    cout << "Double version called: " << maximum("Rishi", "Bishi") << endl;


    // auto max {maximum(a,d)}; //will give a compiler error because you can only add T,T in the template, however we here are adding an int and a double

    //however we can do explicit conversion from int to double or vice versa

    auto max = maximum<double>(a,d);
    //this is explicity change `a` to a double and this can be seen in the compiler
    //the explicit conversion can only happen if the compiler thinks it is valid
    //obviuosly string can be converted to a double

    cout << "Char pointer passed: " << maximum(g,i) << endl;

}

template <typename T> T maximum(T a, T b){
    return (a > b) ? a : b;

    //logic in the template should be supported by the types you are calling the function from.
}

//check compiler insights at cppinsights.io