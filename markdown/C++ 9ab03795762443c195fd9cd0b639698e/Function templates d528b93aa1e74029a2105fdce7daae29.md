# Function templates

- Allow you to write a single function that can work with different data types
- Use placeholder types (template parameters) for parameter types, return types, and types used in the function body
- Are defined using the `template` keyword followed by the template parameter declaration in angle brackets `<>`
- Placeholder types are typically named with a single uppercase letter like `T`

**Syntax**:

```cpp
template <typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
		/*logic in the template should be 
		supported by the types you are calling 
		the function from.*/
}
```

templates are not actual C++ code, but a blueprint that the compiler will use to generate code, and hence this helps with code repetition while overloading functions.

Once an instance of a function is generated by the compiler using the template, if we call the function again with the same instance the compiler will not generate the code again instead will use the last instance.

**Using references:**

```cpp
template <typename T> 
const T& maximum(const T& a, const T& b); 
// Declaration
```

**Calling the instances:**

```cpp
int main()
{
    cout << "Int version: " 
    << maximum(10, 20) << endl;
    cout << "Double version: " <
    < maximum(100.44, 99.34) << endl;
    cout << "Double version: " 
    << maximum("Rishi", "Bishi") << endl;
}
```

if we pass a pointer to the template, it will compare addresses, and then if we dereference that address, we may not get the maximum value, as the function is comparing the functions.

**Template type deduction and explicit arguments:**

```cpp
int a = 34;
int b = 8;
double c {45.67};
double d {10.45};

// auto max {maximum(a,d)};
```

Here we tried to call `maximum(int, double)` which will leave us with a compiler error: Hence we can explicitly request the compiler to convert the int to double or vice versa.

```cpp
auto max = maximum<double>(a,d);
```

the explicit conversion can only happen if the compiler thinks it is valid, obviously, the string can be converted to a double.

**Template specialization:**

Allows you to provide a specialized implementation of a function template for specific template arguments. It enables you to optimize the behavior of templates for particular types or fix issues that may arise when instantiating the template with certain arguments.

Example: 

```cpp
template <>
const char* maximum<const char*> 
(const char* a, const char* b){
    cout << "Specialization called" << endl;
    return (strcmp(a,b) > 0) ? a : b;
}
```

we can bypass the template code by specialization for a special type of argument here `const char*` Now we can compare the `const char*` lexicographically with the same function template.

**Functional templates with overloading:**

Explaining priority with template overloads

```cpp
template <typename T> T maximum(T a,T b){
    std::cout << "Template overload called(T)";
    return (a > b) ? a : b; 
}
```

```cpp
const char* maximum(const char* a, const char* b){
	std::cout << "Raw overload called";
	return (std::strcmp(a,b) > 0) ? a : b ; 
}
```

```cpp
template <typename T> T* maximum(T* a, T* b){
	std::cout << "Template overload called (T*) ";
     return (*a > *b)? a : b;
}
```

If the function is precisely called with `const char*`, the request is completed via raw overload and will have high precedence over any instance in this case. The compiler does this to save the overheads required by using templates.

If any other pointer is pushed, the request will be fulfilled by pointer overload.

**Templates with multiple parameters:**

```cpp
template <typename T, typename P> T maximum(T a, P b){
    return (a > b) ? a : b;
};
```

multiple type names can be set to accept arguments, though providing the return type might be an issue.

The above code is valid but is a bad design because changing the provided arguments might change the return type.

```cpp
int main() {
    int a {5};
    double b {3.4};
    //return type becomes `int`
    maximum(a, b);
		//return type becomes `double`    
    maximum(b, a);
}
```

To fix the issue, we can create a `typename` for `ReturnType` to help the compiler concretely identify the return type.

```cpp
template 
<typename ReturnType, typename T, typename P> 
ReturnType maximum(T a, P b){
    return (a > b) ? a : b;
};
```

Now we can concretely define the return type:

```cpp
maximum<int, int, double>(a, b);
//<ReturnType, T, P> or
maximum<int>(a, b);
/*specifying return type,
others can be deduced via the
args provided*/
```

Preferably place the `ReturnType` `typename` in the first position.

or we can use default the `ReturnType` and by doing this, we will have the flexibility to specify the return type.

```cpp
template 
<typename ReturnType = double, 
typename T, typename P> 
ReturnType maximum(T a, P b){
    return (a > b) ? a : b;
};
```

**Template return type with `auto` deduction:**

```cpp
template <typename T, typename P> 
auto maximum(T a, P b){
    return (a > b) ? a : b;
};
```

The largest type involved in type names will be deduced as the return type. Hence passing `int` and `double` as arguments will result in a return type of `double`.  

Similarly, as discussed before while using `auto` type deduction, the template/function canâ€™t be separated into definition and declaration.

**`decltype` and trailing return types:**

`decltype` is a keyword that is used to inspect the declared type of an entity or the type of an expression. It allows you to extract the type of a variable or expression without knowing its actual type beforehand.

```cpp
int a {9};
double b {5.5}
cout << sizeof(decltype((a>b) ? a : b));
//8
```

This will print the size based on the size of datatypes in memory and not based on the value at which they are initialized. 

Declaring a variable based on `decltype`: 

```cpp
decltype((a>b) ? a : b) c = 7.8;
//will initialize to double
```

Using `decltype` as a return type:

```cpp
template 
<typename T, typename P> 
decltype((a>b)?a:b) maximum(T a, P b){
  return (a > b) ? a : b;
};
```

This will not compile, because we are trying to access the arguments provided even before they are initialized, to solve this, trailing return types can be used.

Trailing return types:

```cpp
template <typename T, typename P> 
auto maximum(T a, P b) 
-> decltype((a>b) ? a : b){
  return (a > b) ? a : b;
};
```

`auto` is used as a placeholder, and the template can now deduce the return type based on `decltype` using trailing returns. and hence we can also separate the function into declaration and datatype.

**Non-type `template` parameters:**

In a function template, non-type template parameters are used to specify constant values that can affect the behavior of the function. These parameters can be used for various purposes, such as controlling the size of an array, defining limits, or customizing behavior based on compile-time constants.

Example:

```cpp
template <size_t size/*this*/, typename T>
T calculate_sum(T array[size])
{
  T sum{};
  for (int i{}; i < size; i++)
    {sum += array[i];}
  return sum;
}
```

Since the size is known at compile time, the compiler can optimize the generated code, potentially leading to better performance compared to runtime size checks.

Using `double` as a non-type template typename is only supported by g++11.

**Auto function templates:**

These can also be used in place of using `template`;

 Will return the largest convertible datatype.

```cpp
auto maximum(auto a, auto b){
/*..*/
}
```

**Type names with lambda functions:**

```cpp
auto func = [](auto a, auto b) {
  return a + b;
};
```

Here we might want to enforce adding same type of arguments to this lambda function, and avoid something like this:

 `function(10, 5.67)` 

```cpp
auto function = [] <typename T>(T a, T b) 
{return a + b;};
```

This is only valid in C++20 or onwards.

**Type traits:**

Type traits are a set of classes and templates that provide information about types at compile-time.

Example:

```cpp
is_integral<int>::value
//or
is_integral_v<int>
```

provides true or false. and it doesn't accept variables, instead accepts datatypes or type names.

We can pair these with `static_assert` to do appropriate checks for a functional template.

```cpp
void print_number(T a)
{
  static_assert(is_integral<T>::value,
   "T must be integral");
  cout << a << endl;
}
```

Now it is a template, but will only expect `char`, `int`, `bool`.

 

**`if constexpr` with templates:**

using `constexpr` we can do function dispatch and discard some branches which we might not need at compile-time to optimize the code.  

Example functions 

```cpp
void func_floating_point  (double d) {
	std::cout << 
	"func_floating_point called" << std::endl;
} 
void func_integral(int i) { 
	std::cout 
	<< "func_integral called" << std::endl;
} 
```

Example template:

```cpp
template <typename T>
void func(T t)
{
    if constexpr(std::is_integral_v<T>)
        func_integral(t);
    else if constexpr(std::is_floating_point_v<T>)
        func_floating_point(t);
    else
        static_assert(
        std::is_integral_v<T> 
        || std::is_floating_point_v<T>,
			"must be integral or floating point");
}
```

Calling:

```cpp
int main(){
    func(12);
}
```

The compiler will discard all the other branches, and in the preprocessor stage, it will only retain the required code.