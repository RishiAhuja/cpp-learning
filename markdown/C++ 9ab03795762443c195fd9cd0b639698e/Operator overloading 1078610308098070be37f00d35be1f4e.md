# Operator overloading

Operator overloading enables the use of operators with user-defined types, providing a way to define how these operators behave when applied to instances of classes.

```cpp
Return_Type operator OperatorSymbol(Parameters) {
    // Function body
}
```

To do something like this in our trusty `Point` class with 2 member variables:

```cpp
Point p1(10, 20);
cout << p1[0] << endl; 
//expected output: 10
```

We need to overload the `[]` operator to do the following function like this:

```cpp
double& operator[] (size_t index){
		assert(index < 2);
		//to ensure no one passes more than 2
		if(index == 0){
			return m_x;
		}
		if(index == 1){
			return m_y;
		}
	}
```

Now the following operator can be used to print the member variables. The operator is binary and this is applied in the `Point` on which we are working on.

**Stream insertion operator:**

as a member function:

```cpp
	std::ostream& operator<<(std::ostream& os){
		os << "Point [ x : " << m_x << 
		", y : " << m_y << "]";
		 //to allow chaining
		return os;
	}
```

The overloads work like this: `object.operator<<stream`

```cpp
Point p1 (10, 20);
p1 << std::cout;
```

As a non-member function:

```cpp
inline std::ostream& 
operator<<(std::ostream& os, const Point& point){
	os << "Point [ x : " << point.m_x 
	<< ", y : " << point.m_y << "]";
	//to allow chaining
	return os;
}
```

As we don’t have direct access to the point variable because this is a free-standing function, we might need to also accept the object as a parameter and make this function a `friend` of our point class.

```cpp
cout << p1 << endl;
```

**Stream extraction operator:**

As a free-standing function:

```cpp
inline std::istream& 
operator>>(std::istream& is, Point& p){
	double x;
	double y;
	std::cout << 
	"Please input [x,y] with spaces one by one: " 
	<< std::endl;
	is >> x >> y;

	p.m_x = x;
	p.m_y = y;
	return is;
}
```

**Unary pre and postfix operators:**

Prefix overload:

```cpp
void operator++() {
		++m_x;
		++m_y;
	}
```

Postfix overload:

```cpp
//dummy int
Point operator++(int){
		Point local_point(*this);
		++(*this);
		return local_point;
	}
```

**Copy overload:**

```cpp
Point operator=(Point &right_operand){
			this->m_x = right_operand.m_x;
			this->m_y = right_operand.m_y;
	return *this;
}
```

This overload can be used to copy one object to another, but if some member variables are pointers then we need to first delete the memory of the left operand and assign the memory to from right pointer.

```cpp
Point operator=(Point &right_operand){
			delete rand_ptr;
			this->m_x = right_operand.m_x;
			this->m_y = right_operand.m_y;
			this->rand_ptr = 
			new double(*right_operand.rand_ptr);
			//or this as per the usecase
			//this->rand_ptr = right_operand.rand_ptr;
	return *this;
}
```

We also need to check for self-assignment:

```cpp
Point operator=(Point &right_operand){
		if(this!= &right_operand){
			delete rand_ptr;
			this->m_x = right_operand.m_x;
			this->m_y = right_operand.m_y;
			this->rand_ptr = right_operand.rand_ptr;
		}
	return *this;
}
```

If we don’t do this check, we will first delete the memory of the left operand, but because the right operand is the same as the right, we won’t have any memory to assign, and the program will crash.

**Functors:**

A **functor** is an object that can be treated as if it were a function. This is achieved by overloading the function called operator `()` within a class or struct.

```cpp
class Adder {
private:
    int value;
public:
    Adder(int v) : value(v) {}
    
    int operator()(int x) const {
        return value + x;
    }
};

int main() {
    Adder addFive(5);
    cout << "Result: " << addFive(10) << endl; 
    // Calls the functor
    return 0;
}
```

**Comparison defaulted equality and overloads:** 

We can create our own comparison and equality overloads but we also have a defaulted equality overload, which is generated by the compiler, and It performs a shallow comparison. The compiler also generates a  `!=` overload as a complement to the equality overload and we are only required to manage a single equality operator:

```cpp
bool operator==(const Point& right_operand) const 
= default;
```

> We need to use our proprietary overload if the need to perform a deep comparison (comparing member variables which are accepted as pointers)
> 

**Rel Ops namespace:**

The `std::rel_ops` namespace provides a way to define relational operators based on the presence of only two operators:

```
operator==
```

(equality) and

```
operator<
```

(less than). This namespace includes four additional operators:

- `operator!=` (not equal)
- `operator>` (greater than)
- `operator<=` (less than or equal to)
- `operator>=` (greater than or equal to)

This comes under the `<utility>` header and can be used like `using namespace rel_ops`, Now you need to only define  `<` and `==` operators and others will be generated for you by the compiler.

> rel_ops will be depreciated after C++20
> 

**Three-way comparison (spaceship `<=>`) operator:**

> Available in C++20 and above
> 

The **three-way comparison operator**, introduced in C++20, is commonly referred to as the **spaceship operator** (`<=>`). This operator allows for a single comparison that can yield three 
possible outcomes: less than, equal to, or greater than. It simplifies the process of defining comparison logic for user-defined types by providing a standardized method to express these relationships.

```cpp
auto result = a <=> b;
```

The `result` will be of type `std::strong_ordering`, `std::weak_ordering`, or `std::partial_ordering`, depending on how the operator is defined for the types involved. The return values can be interpreted as follows:

- **Negative value**: Indicates that A<B
- **Zero**: Indicates that A=B
- **Positive value**: Indicates that A>B

These can’t be compared to `int` which is valued at 0, because its output is not an integer as mentioned above. We need to compare this to a literal 0.

```cpp
int n = 0;

if(result > 0)
	cout << "A>B" << endl;

//will omit an error:
if(result > n)
	cout << "A>B" << endl;
```

- **Strong Ordering**: Distinguishes between equal and equivalent values. This ordering is used when items are fully interchangeable.
    - Possible results: less, equal, greater.
    - “hello” = “hello” (equal)
    - “hello” = “Hello” (equivalent)
- **Weak Ordering**: Similar to strong ordering but treats equivalent items as indistinguishable.
    - Possible results: less, equivalent, greater.
- **Partial Ordering**: Allows for comparisons where some items cannot be compared directly (e.g., NaN in floating-point comparisons).
    - Possible results: less, equivalent, greater, unordered.

**Using spaceship infrastructure as operator overloads:**

```cpp
auto operator<=>(const Point& p) const = default;
```

Now you don’t need to manage multiple different overload functions, the compiler will try its best to generate the operator overloads using this infrastructure in modern C++20. Now you can directly use `==`, `!=`, `>=`, `<=`, `<`, `>` operators. 

This will only work when We have member variables about which the compiler knows how to compare them, Let’s say we have a member variable that is another class, Then the compiler might not know how to use the infrastructure. 

```cpp
private:
	int a{1};
	int b{3};
	int c{6};
	int d{8}
```

```cpp
private:
	int a{1};
	int b{3};
	int c{6};
	Integer d;
```

Will work as expected using the defaulted overload.

Will check the `Integer` class, If the compiler doesn’t find the definition of its comparison, then it will convert the overload as `default` to `delete`.

Hence in the integer class, we need to at least define `==` and `<` overloads and the three-way infrastructure can be synthesized from these two overloads.

Additional overloads which require to be added in the Integer class:

```cpp
bool operator==(const Integer& right) const{
    return (m_wraped_int == right.m_wraped_int);
}
bool operator<(const Integer& right) const{
    return (m_wraped_int < right.m_wraped_int);
}
```

We also need to specify our ordering here for this purpose to define the use synthesis of spaceship infrastructure in the `Integer` class.

```cpp
//auto operator<=>(const Point& p) const = default;
//should be changed to 
std::strong_ordering operator<=>(const Point& p) const = default;
```

**Custom spaceship overloads:**

We requested a partial order because we might encounter `Nan` objects, and we can return  `unordered` requests.

```cpp
std::partial_ordering 
operator<=>(const Point& right) const{
		auto lhs_length = this->length();
  	auto rhs_length = right.length();
    
    	if (lhs_length < rhs_length) {
        	return std::partial_ordering::less;
    	} else if (lhs_length > rhs_length) {
        	return std::partial_ordering::greater;
    	} else if {
        	return std::partial_ordering::equivalent;
    	} else{
				return std::partial_ordering::unordered;
		}
	}
```